<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ØªØ³Øª Ù…Ø´Ú©Ù„ Ú©Ù„ÛŒØ¯Ù‡Ø§ - GlobGram</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
        .container { max-width: 800px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; }
        .output { background: #000; color: #0f0; padding: 15px; border-radius: 5px; font-family: monospace; margin: 10px 0; min-height: 300px; }
        .btn { padding: 10px 20px; margin: 5px; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; }
        .btn-danger { background: #ff4757; color: white; }
        .btn-success { background: #2ed573; color: white; }
        .btn-info { background: #3742fa; color: white; }
        .status { padding: 10px; margin: 10px 0; border-radius: 5px; }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” ØªØ´Ø®ÛŒØµ Ù…Ø´Ú©Ù„ "invalid-event" Ø¯Ø± GlobGram</h1>
        
        <div id="status"></div>
        
        <div>
            <button class="btn btn-info" onclick="runDiagnostics()">ğŸ” ØªØ´Ø®ÛŒØµ Ù…Ø´Ú©Ù„</button>
            <button class="btn btn-danger" onclick="clearAndRegenerate()">ğŸ—‘ï¸ Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† Ùˆ Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù„ÛŒØ¯ Ø¬Ø¯ÛŒØ¯</button>
            <button class="btn btn-success" onclick="testEventCreation()">ğŸ“ ØªØ³Øª Ø§ÛŒØ¬Ø§Ø¯ Event</button>
            <button class="btn btn-info" onclick="testRelayConnection()">ğŸŒ ØªØ³Øª Ø§ØªØµØ§Ù„ Relay</button>
        </div>
        
        <div class="output" id="output">Ø¢Ù…Ø§Ø¯Ù‡ Ø¨Ø±Ø§ÛŒ ØªØ³Øª...</div>
    </div>

    <script type="module">
        const output = document.getElementById('output');
        const status = document.getElementById('status');
        
        function log(msg, type = 'info') {
            const timestamp = new Date().toLocaleTimeString('fa-IR');
            const prefix = type === 'error' ? 'âŒ' : type === 'warn' ? 'âš ï¸' : type === 'success' ? 'âœ…' : 'â„¹ï¸';
            const line = `[${timestamp}] ${prefix} ${msg}`;
            console.log(line);
            output.innerHTML += line + '\n';
            output.scrollTop = output.scrollHeight;
        }
        
        function setStatus(msg, type = 'info') {
            status.innerHTML = `<div class="status ${type}">${msg}</div>`;
        }
        
        // Helper functions
        const hexToBytes = (hex) => {
            if (hex.length % 2 !== 0) throw new Error('Ø·ÙˆÙ„ hex Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª');
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
            }
            return bytes;
        };
        
        const bytesToHex = (bytes) => {
            return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
        };
        
        // Main diagnostic function
        window.runDiagnostics = async function() {
            output.innerHTML = '';
            log('ğŸ” Ø´Ø±ÙˆØ¹ ØªØ´Ø®ÛŒØµ Ù…Ø´Ú©Ù„...');
            
            try {
                // 1. Check localStorage
                const sk = localStorage.getItem('nostr_sk');
                log(`Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ù…ÙˆØ¬ÙˆØ¯: ${!!sk}`);
                log(`Ø·ÙˆÙ„ Ú©Ù„ÛŒØ¯: ${sk?.length || 'Ù†Ø§Ù…Ø´Ø®Øµ'}`);
                log(`ÙØ±Ù…Øª hex Ù…Ø¹ØªØ¨Ø±: ${/^[0-9a-f]{64}$/i.test(sk || '')}`);
                
                if (!sk) {
                    setStatus('âŒ Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯! Ø§Ø¨ØªØ¯Ø§ ÛŒÚ© Identity Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†ÛŒØ¯.', 'error');
                    return;
                }
                
                // 2. Test hex conversion
                let skBytes;
                try {
                    skBytes = hexToBytes(sk);
                    log(`âœ… ØªØ¨Ø¯ÛŒÙ„ hex Ø¨Ù‡ bytes Ù…ÙˆÙÙ‚: ${skBytes.length} Ø¨Ø§ÛŒØª`);
                } catch (e) {
                    log(`âŒ Ø®Ø·Ø§ Ø¯Ø± ØªØ¨Ø¯ÛŒÙ„ hex: ${e.message}`, 'error');
                    setStatus('âŒ Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ Ú©ÙˆØ±Ù¾Øª Ø´Ø¯Ù‡ Ø§Ø³Øª. Ú©Ù„ÛŒØ¯ Ø¬Ø¯ÛŒØ¯ Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†ÛŒØ¯.', 'error');
                    return;
                }
                
                // 3. Test nostr-tools import
                let nostrTools;
                try {
                    nostrTools = await import('nostr-tools');
                    log(`âœ… nostr-tools Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª import Ø´Ø¯`);
                    log(`Ø§Ø¨Ø²Ø§Ø±Ù‡Ø§ÛŒ Ù…ÙˆØ¬ÙˆØ¯: ${Object.keys(nostrTools).slice(0, 10).join(', ')}...`);
                } catch (e) {
                    log(`âŒ Ø®Ø·Ø§ Ø¯Ø± import nostr-tools: ${e.message}`, 'error');
                    setStatus('âŒ Ù…Ø´Ú©Ù„ Ø¯Ø± Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡ nostr-tools', 'error');
                    return;
                }
                
                // 4. Test public key generation
                let pk;
                try {
                    pk = nostrTools.getPublicKey(skBytes);
                    log(`âœ… Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯: ${pk.slice(0, 16)}...`);
                } catch (e) {
                    log(`âŒ Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ: ${e.message}`, 'error');
                    setStatus('âŒ Ù…Ø´Ú©Ù„ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ', 'error');
                    return;
                }
                
                // 5. Test event creation
                try {
                    const now = Math.floor(Date.now() / 1000);
                    const template = {
                        kind: 1,
                        created_at: now,
                        content: 'ØªØ³Øª Ù¾ÛŒØ§Ù… Ø§Ø² GlobGram',
                        tags: []
                    };
                    
                    const event = nostrTools.finalizeEvent(template, skBytes);
                    log(`âœ… Event Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯: ID=${event.id?.slice(0, 16)}...`);
                    log(`  Ù†ÙˆØ¹: ${event.kind}`);
                    log(`  Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ: ${event.pubkey?.slice(0, 16)}...`);
                    log(`  Ø·ÙˆÙ„ Ø§Ù…Ø¶Ø§: ${event.sig?.length}`);
                    
                    // Validate event fields
                    const required = ['id', 'pubkey', 'created_at', 'kind', 'tags', 'content', 'sig'];
                    const missing = required.filter(field => !(field in event));
                    
                    if (missing.length > 0) {
                        log(`âŒ ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ Ù†Ø§Ù‚Øµ: ${missing.join(', ')}`, 'error');
                        setStatus('âŒ Event Ù†Ø§Ù…Ø¹ØªØ¨Ø± - ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ Ù†Ø§Ù‚Øµ', 'error');
                        return;
                    }
                    
                    // Check field validity
                    if (event.pubkey !== pk) {
                        log(`âŒ Ø¹Ø¯Ù… ØªØ·Ø§Ø¨Ù‚ Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ!`, 'error');
                        log(`  ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯Ù‡: ${pk}`);
                        log(`  Ø¯Ø± Event: ${event.pubkey}`);
                        setStatus('âŒ Ø¹Ø¯Ù… ØªØ·Ø§Ø¨Ù‚ Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ Ø¯Ø± Event', 'error');
                        return;
                    }
                    
                    if (!event.id || event.id.length !== 64) {
                        log(`âŒ ID Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø·ÙˆÙ„=${event.id?.length}`, 'error');
                        setStatus('âŒ ID Event Ù†Ø§Ù…Ø¹ØªØ¨Ø±', 'error');
                        return;
                    }
                    
                    if (!event.sig || event.sig.length !== 128) {
                        log(`âŒ Ø§Ù…Ø¶Ø§ Ù†Ø§Ù…Ø¹ØªØ¨Ø±: Ø·ÙˆÙ„=${event.sig?.length}`, 'error');
                        setStatus('âŒ Ø§Ù…Ø¶Ø§ Event Ù†Ø§Ù…Ø¹ØªØ¨Ø±', 'error');
                        return;
                    }
                    
                    log('âœ… ØªÙ…Ø§Ù… Ø¨Ø±Ø±Ø³ÛŒâ€ŒÙ‡Ø§ Ù…ÙˆÙÙ‚ - Event Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª');
                    setStatus('âœ… Ù‡Ù…Ù‡ Ú†ÛŒØ² Ø¯Ø±Ø³Øª Ø§Ø³Øª! Ù…Ø´Ú©Ù„ Ù…Ù…Ú©Ù† Ø§Ø³Øª Ø§Ø² Ø³Ù…Øª relay Ø¨Ø§Ø´Ø¯.', 'success');
                    
                } catch (e) {
                    log(`âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Event: ${e.message}`, 'error');
                    setStatus('âŒ Ù…Ø´Ú©Ù„ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Event', 'error');
                    return;
                }
                
            } catch (e) {
                log(`âŒ Ø®Ø·Ø§ÛŒ ØºÛŒØ±Ù…Ù†ØªØ¸Ø±Ù‡: ${e.message}`, 'error');
                setStatus('âŒ Ø®Ø·Ø§ÛŒ ØºÛŒØ±Ù…Ù†ØªØ¸Ø±Ù‡ Ø¯Ø± ØªØ´Ø®ÛŒØµ', 'error');
            }
        };
        
        // Clear and regenerate keys
        window.clearAndRegenerate = async function() {
            if (!confirm('Ø¢ÛŒØ§ Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ Ú©Ù‡ Ù…ÛŒâ€ŒØ®ÙˆØ§Ù‡ÛŒØ¯ ØªÙ…Ø§Ù… Ú©Ù„ÛŒØ¯Ù‡Ø§ Ùˆ Ø¯Ø§Ø¯Ù‡â€ŒÙ‡Ø§ Ø±Ø§ Ù¾Ø§Ú© Ú©Ù†ÛŒØ¯ØŸ')) {
                return;
            }
            
            output.innerHTML = '';
            log('ğŸ—‘ï¸ Ù¾Ø§Ú© Ú©Ø±Ø¯Ù† localStorage...');
            
            // Clear all GlobGram data
            const keys = Object.keys(localStorage);
            keys.forEach(key => {
                if (key.includes('nostr') || key.includes('globgram') || key.includes('chat') || key.includes('relay')) {
                    localStorage.removeItem(key);
                    log(`Ù¾Ø§Ú© Ø´Ø¯: ${key}`);
                }
            });
            
            try {
                // Generate new key
                const nostrTools = await import('nostr-tools');
                const secret = nostrTools.generateSecretKey();
                const hexSecretKey = bytesToHex(secret);
                const publicKey = nostrTools.getPublicKey(secret);
                
                localStorage.setItem('nostr_sk', hexSecretKey);
                
                log(`âœ… Ú©Ù„ÛŒØ¯ Ø¬Ø¯ÛŒØ¯ Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯:`);
                log(`  Ú©Ù„ÛŒØ¯ Ø¹Ù…ÙˆÙ…ÛŒ: ${publicKey.slice(0, 16)}...`);
                log(`  Ú©Ù„ÛŒØ¯ Ø®ØµÙˆØµÛŒ: ${hexSecretKey.slice(0, 16)}...`);
                
                setStatus('âœ… Ú©Ù„ÛŒØ¯ Ø¬Ø¯ÛŒØ¯ Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§ÛŒØ¬Ø§Ø¯ Ø´Ø¯! ØµÙØ­Ù‡ Ø§ØµÙ„ÛŒ Ø±Ø§ refresh Ú©Ù†ÛŒØ¯.', 'success');
                
            } catch (e) {
                log(`âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù„ÛŒØ¯ Ø¬Ø¯ÛŒØ¯: ${e.message}`, 'error');
                setStatus('âŒ Ù…Ø´Ú©Ù„ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù„ÛŒØ¯ Ø¬Ø¯ÛŒØ¯', 'error');
            }
        };
        
        // Test event creation specifically
        window.testEventCreation = async function() {
            output.innerHTML = '';
            log('ğŸ“ ØªØ³Øª Ø§ÛŒØ¬Ø§Ø¯ Event...');
            
            const sk = localStorage.getItem('nostr_sk');
            if (!sk) {
                setStatus('âŒ Ø§Ø¨ØªØ¯Ø§ Ú©Ù„ÛŒØ¯ Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†ÛŒØ¯', 'error');
                return;
            }
            
            try {
                const nostrTools = await import('nostr-tools');
                const skBytes = hexToBytes(sk);
                
                // Test different event types
                const eventTypes = [
                    { kind: 1, content: 'ØªØ³Øª Ù¾ÛŒØ§Ù… Ø¹Ø§Ø¯ÛŒ', desc: 'Ù¾ÛŒØ§Ù… Ø¹Ø§Ø¯ÛŒ' },
                    { kind: 4, content: 'ØªØ³Øª Ù¾ÛŒØ§Ù… Ù…Ø³ØªÙ‚ÛŒÙ…', desc: 'Ù¾ÛŒØ§Ù… Ù…Ø³ØªÙ‚ÛŒÙ…', tags: [['p', 'test']] },
                    { kind: 42, content: 'ØªØ³Øª Ù¾ÛŒØ§Ù… Ú¯Ø±ÙˆÙ‡ÛŒ', desc: 'Ù¾ÛŒØ§Ù… Ú¯Ø±ÙˆÙ‡ÛŒ', tags: [['e', 'test']] }
                ];
                
                for (const eventType of eventTypes) {
                    try {
                        const template = {
                            kind: eventType.kind,
                            created_at: Math.floor(Date.now() / 1000),
                            content: eventType.content,
                            tags: eventType.tags || []
                        };
                        
                        const event = nostrTools.finalizeEvent(template, skBytes);
                        log(`âœ… ${eventType.desc}: ID=${event.id.slice(0, 12)}...`);
                        
                    } catch (e) {
                        log(`âŒ Ø®Ø·Ø§ Ø¯Ø± ${eventType.desc}: ${e.message}`, 'error');
                    }
                }
                
                setStatus('âœ… ØªØ³Øª Ø§ÛŒØ¬Ø§Ø¯ Eventâ€ŒÙ‡Ø§ Ú©Ø§Ù…Ù„ Ø´Ø¯', 'success');
                
            } catch (e) {
                log(`âŒ Ø®Ø·Ø§ Ø¯Ø± ØªØ³Øª: ${e.message}`, 'error');
                setStatus('âŒ Ù…Ø´Ú©Ù„ Ø¯Ø± ØªØ³Øª Ø§ÛŒØ¬Ø§Ø¯ Event', 'error');
            }
        };
        
        // Test relay connection
        window.testRelayConnection = async function() {
            output.innerHTML = '';
            log('ğŸŒ ØªØ³Øª Ø§ØªØµØ§Ù„ Ø¨Ù‡ Relay...');
            
            const relayUrl = 'wss://relay1.matrus.org';
            
            try {
                const ws = new WebSocket(relayUrl);
                
                ws.onopen = () => {
                    log(`âœ… Ø§ØªØµØ§Ù„ Ø¨Ø±Ù‚Ø±Ø§Ø± Ø´Ø¯: ${relayUrl}`);
                    setStatus('âœ… Ø§ØªØµØ§Ù„ Ø¨Ù‡ relay Ù…ÙˆÙÙ‚', 'success');
                    
                    // Send a simple REQ to test
                    const req = JSON.stringify(['REQ', 'test', { kinds: [1], limit: 1 }]);
                    ws.send(req);
                    log('ğŸ“¤ Ø¯Ø±Ø®ÙˆØ§Ø³Øª ØªØ³Øª Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯');
                };
                
                ws.onmessage = (msg) => {
                    try {
                        const data = JSON.parse(msg.data);
                        log(`ğŸ“¥ Ù¾Ø§Ø³Ø® relay: ${data[0]} ${data[1] || ''}`);
                        
                        if (data[0] === 'NOTICE') {
                            log(`ğŸ“¢ Ø§Ø¹Ù„Ø§Ù† relay: ${data[1]}`);
                        }
                    } catch (e) {
                        log(`ğŸ“¥ Ù¾ÛŒØ§Ù… Ø®Ø§Ù…: ${msg.data}`);
                    }
                };
                
                ws.onerror = (error) => {
                    log(`âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ØªØµØ§Ù„ relay: ${error}`, 'error');
                    setStatus('âŒ Ù…Ø´Ú©Ù„ Ø¯Ø± Ø§ØªØµØ§Ù„ Ø¨Ù‡ relay', 'error');
                };
                
                ws.onclose = (event) => {
                    log(`ğŸ”Œ Ø§ØªØµØ§Ù„ relay Ø¨Ø³ØªÙ‡ Ø´Ø¯: Ú©Ø¯=${event.code}`);
                    if (event.code !== 1000) {
                        setStatus('âš ï¸ Ø§ØªØµØ§Ù„ relay ØºÛŒØ±Ø¹Ø§Ø¯ÛŒ Ø¨Ø³ØªÙ‡ Ø´Ø¯', 'warning');
                    }
                };
                
                // Close after 5 seconds
                setTimeout(() => {
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.close();
                        log('ğŸ• Ø§ØªØµØ§Ù„ Ø¨Ø¹Ø¯ Ø§Ø² 5 Ø«Ø§Ù†ÛŒÙ‡ Ø¨Ø³ØªÙ‡ Ø´Ø¯');
                    }
                }, 5000);
                
            } catch (e) {
                log(`âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø§ØªØµØ§Ù„: ${e.message}`, 'error');
                setStatus('âŒ Ù…Ø´Ú©Ù„ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø§ØªØµØ§Ù„ WebSocket', 'error');
            }
        };
        
        // Auto-run diagnostics on load
        setTimeout(() => {
            runDiagnostics();
        }, 1000);
    </script>
</body>
</html>
